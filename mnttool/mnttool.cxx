// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include <libintl.h>
#include "mnttool.h"
// (c) Robert Shingledecker 2008-2011
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <locale.h>
#include <stdint.h>
#include <FL/Fl_Button.H>
#include <sys/inotify.h>
using namespace std;
/**
   for watching /etc/fstab
*/
static int infd = -1; // inotify fd
static void infd_read(void *); 
static void reset_watch(); 
/**
   other globals
*/
static int size, selected, xPos, yPos; 
static string filemgr, winPos; 
static istringstream ins; 
vector<string> mountList; 
static vector<int> mountState; 
static vector<Fl_Button*> btn; 
vector<string> mountLabels; 

void getPos() {
  xPos = w->x();
  yPos = w->y();
}

void refresh() {
  getMountables();
  if ( size == 0 ) 
    exit(1);
  
  pack->clear();
  
  for (int i=0; i < size; i++)
  {  
     Fl_Button* btn[i];
     
     btn[i] = new Fl_Button(0,0,80,25);
     btn[i]->label(mountList[i].c_str());
     btn[i]->tooltip(mountLabels[i].c_str());
     btn[i]->callback((Fl_Callback*)btnCallback,(void*)(uintptr_t)i);
  
     if ( mountState[i] == 0)
        btn[i]->color((Fl_Color)2);
     else
        btn[i]->color((Fl_Color)1);
        
     pack->add(btn[i]);
        
  }
  
  Fl_Button* btnRefresh;
  btnRefresh = new Fl_Button(0,0,80,25);
  btnRefresh->label("Refresh");
  btnRefresh->callback((Fl_Callback*)btnRefreshCallback);
  pack->add(btnRefresh);
  
  selected = 0;
  pack->redraw();
  w->resize(0,0,80,(25*(size+1)));
  w->position(xPos,yPos);
  w->redraw();
}

void getMountables() {
  mountList.clear();
  mountState.clear();
  
   system("mountables.sh");
  
  ifstream fin("/tmp/mountables");
  string line;
  string commandHead = "grep '/mnt/";
  string commandTail = " ' /etc/mtab >/dev/null";
  
  while ( getline(fin,line) )
  {
     int sepator = line.find("~",0);
     string device = line.substr(0, sepator);
     string label = line.substr(sepator+1);
     mountList.push_back(device);
     mountState.push_back(system((commandHead + device + commandTail).c_str()));
     mountLabels.push_back(label);
  }   
  fin.close();
  unlink("/tmp/mountables");
  
  size = mountList.size();
}

void btnCallback(Fl_Widget*, void* userdata) {
  getPos();
  int results;
  selected = (long)userdata;
  if (mountState.at(selected) == 0)   // mounted
  {
     results = system(("sudo umount /dev/" + mountList.at(selected)).c_str());
     if (results == 0)
     {
        pack->child(selected)->color((Fl_Color)1);         
        mountState.at(selected)=256;
     }    
  }   
  else
  {
     results = system(("sudo mount /dev/" + mountList.at(selected)).c_str());
     if (results == 0)
     {
        pack->child(selected)->color((Fl_Color)2);         
        mountState.at(selected)=0;
        if (filemgr.length() > 0)
        {
           system((filemgr + " /mnt/" + mountList.at(selected) +"&" ).c_str());
           exit(0);
        }
     }
  }
}

void btnRefreshCallback(Fl_Widget*, void* userdata) {
  getPos();
  system("sudo rebuildfstab");
  refresh();
}

/**
   called by FLTK when infd has data; schedules infd_read()
*/
static void infd_ready_cb(int, void *) {
  Fl::add_timeout(0, infd_read); // schedule infd_read
}

/**
   clear inotify queue, refresh, reset_watch
*/
static void infd_read(void *) {
  // read/flush the inotify buf - we're only watching one event. 
  const unsigned iebuflen = sizeof(inotify_event)*32;
  char iebuf[iebuflen];
  read(infd, &iebuf, iebuflen); 
  
  refresh();
  reset_watch(); // set new watch
}

/**
   add inotify watch on /etc/fstab; ask FLTK to call infd_ready_cb() on changes
*/
static void reset_watch() {
  if(infd < 0) infd = inotify_init(); 
      if(infd < 0) {
        Fl::warning("mnttool: inotify_init() failed in reset_watch(). Auto-update disabled.");
        return; 
      }
    
      if(inotify_add_watch(infd, "/etc/fstab", IN_CLOSE_WRITE | IN_ONESHOT) < 0) {
        Fl::warning("mnttool: inotify_add_watch() failed in reset_watch(). Auto-update disabled.");
        close(infd);
        infd = -1;
        return;
      }
    
      Fl::add_fd(infd, FL_READ, infd_ready_cb);
}

Fl_Double_Window *w=(Fl_Double_Window *)0;

Fl_Pack *pack=(Fl_Pack *)0;

int main(int argc, char **argv) {
  Fl::args(argc, argv);
  setlocale(LC_ALL, "");
  bindtextdomain("tinycore","/usr/local/share/locale");
  textdomain("tinycore");
  { w = new Fl_Double_Window(85, 745, gettext("mnttool"));
    { pack = new Fl_Pack(0, 0, 80, 500);
      pack->end();
    } // Fl_Pack* pack
    w->end();
  } // Fl_Double_Window* w
  if (getenv("FILEMGR"))
     filemgr = getenv("FILEMGR");
  
  xPos=80;
  yPos=60;   
  
  if (getenv("MNTTOOL")) { 
     winPos = getenv("MNTTOOL");
     ins.str(winPos);
     ins >> xPos >> yPos;
  }   
     
  refresh();
  reset_watch();
  w->show(argc, argv);
  return Fl::run();
}
