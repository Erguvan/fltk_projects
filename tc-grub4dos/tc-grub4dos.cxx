// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include <libintl.h>
#include "tc-grub4dos.h"
// (c) Robert Shingledecker 2011
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <FL/Fl_File_Chooser.H>
#include <FL/fl_message.H>
#include <locale.h>
using namespace std;
static istringstream iss; 
static string command,msg,heading; 
static int results, locales_set=0, test4grub; 
static string image,type,installMode, target,dev,format,path,boot,flag; 

void cursor_normal() {
  window->cursor(FL_CURSOR_DEFAULT);
Fl::flush();
}

void cursor_wait() {
  window->cursor(FL_CURSOR_WAIT);
Fl::flush();
}

void selectFile() {
  brwTarget->deactivate();
string target = "*" + image + "*";
string title = gettext("Select File for ");
title = title + image;
Fl_File_Chooser chooser("/",target.c_str(), Fl_File_Chooser::SINGLE, title.c_str());
chooser.show();                                             
while(chooser.shown())
  { Fl::wait(); }
  
if ( chooser.value() == NULL )
{
   btnMicro->value(0);
   btnTiny->value(0);
   return;
}
      
path = chooser.value();
Fl::flush();
}

void prepTarget() {
  heading = "Select " + type + " for " + image;
brwTarget->label(heading.c_str());

flag = "-p";

if (! image.empty() )
{
    brwTarget->activate();
    command = "fetch_devices " + flag + " > /tmp/install_work";
    system(command.c_str());
    brwTarget->load("/tmp/install_work");
    unlink("/tmp/install_work");
}
grpButtons->deactivate();
}

static char * mygettext(const char *msgid) {
  if (!locales_set) {

setlocale(LC_ALL, "");
bindtextdomain("tinycore","/usr/local/share/locale");
textdomain("tinycore");

locales_set=1;

}

return gettext(msgid);
}

void btnCB(Fl_Widget*, void*userdata) {
  const string userdatastr = userdata ? (char *) userdata : "";

if ( userdatastr == "begin" )
{
  wWizard->value(wWizard->child(0));
}  

if ( userdatastr == "next" )
{
  wWizard->next();
  if ( grpFormat->visible() && installMode == "embedded") 
     wWizard->next();
  
}

if ( userdatastr == "prev" )
{
  wWizard->prev();
  if ( grpFormat->visible() && installMode == "embedded") 
     wWizard->prev();

}

if ( userdatastr == "last" )
{
  int last = wWizard->children()-1;
  wWizard->value(wWizard->child(last));
}

if (grpType->visible())
   prepTarget();
   
if (grpBoot->visible())
{
   brwBootRef->load("/usr/share/doc/tc/bootOptions.txt");
}
   
if (grpReview->visible())
{
   boot = options->value();
   brwReview->clear();
   brwReview->add(("Source: "+path).c_str());
   brwReview->add(("Type: "+installMode).c_str());
   brwReview->add(("Target: "+dev).c_str());
   brwReview->add(("Format:"+format).c_str());
   brwReview->add(("Options: "+boot).c_str());
}
}

void btnProceedCB(Fl_Widget*, void* userdata) {
  btnProceed->deactivate();
grpButtons->deactivate();
cursor_wait();
command="sudo tc-grub4dos.sh "+path+" "+installMode+" "+dev+" "+format+" "+boot;
cout << command << endl;
FILE *pipe = popen(command.c_str(),"r");
char *mbuf = (char *)calloc(PATH_MAX,sizeof(char));
if (pipe)
{
   brwReview->clear();
   while(fgets(mbuf,PATH_MAX,pipe))
   {
      string line(mbuf);
      brwReview->add(line.c_str());
      Fl::flush();
      brwReview->bottomline(brwReview->size());
   }
   pclose(pipe);
   free(mbuf);
}
cursor_normal();
Fl::flush();
}

Fl_Double_Window *window=(Fl_Double_Window *)0;

Fl_Wizard *wWizard=(Fl_Wizard *)0;

Fl_Group *grpType=(Fl_Group *)0;

Fl_Check_Button *btnMicro=(Fl_Check_Button *)0;

static void cb_btnMicro(Fl_Check_Button*, void* v) {
  image = (const char*)v;
selectFile();
fullpathOutput->value(path.c_str());
prepTarget();
}

Fl_Check_Button *btnTiny=(Fl_Check_Button *)0;

static void cb_btnTiny(Fl_Check_Button*, void* v) {
  image = (const char*)v;
selectFile();
fullpathOutput->value(path.c_str());
prepTarget();
}

Fl_Output *fullpathOutput=(Fl_Output *)0;

static void cb_Frugal(Fl_Check_Button*, void* v) {
  installMode = (const char*)v;
prepTarget();
}

static void cb_Embedded(Fl_Check_Button*, void* v) {
  installMode = (const char*)v;
prepTarget();
}

Fl_Browser *brwTarget=(Fl_Browser *)0;

static void cb_brwTarget(Fl_Browser*, void*) {
  if ( brwTarget->value() )
{
   dev = brwTarget->text(brwTarget->value());
   int partitionNbr;
   iss.str(dev.substr(3,dev.length()));
   iss >> partitionNbr;
   grpButtons->activate();
};
}

Fl_Group *grpFormat=(Fl_Group *)0;

Fl_Group *FormatType=(Fl_Group *)0;

static void cb_No(Fl_Round_Button*, void* v) {
  format = (const char*)v;
}

static void cb_ext2(Fl_Round_Button*, void* v) {
  format = (const char*)v;
}

static void cb_ext3(Fl_Round_Button*, void* v) {
  format = (const char*)v;
}

static void cb_ext4(Fl_Round_Button*, void* v) {
  format = (const char*)v;
}

static void cb_vfat(Fl_Round_Button*, void* v) {
  format = (const char*)v;
}

Fl_Group *grpBoot=(Fl_Group *)0;

Fl_Browser *brwBootRef=(Fl_Browser *)0;

Fl_Input *options=(Fl_Input *)0;

Fl_Group *grpReview=(Fl_Group *)0;

Fl_Browser *brwReview=(Fl_Browser *)0;

Fl_Button *btnProceed=(Fl_Button *)0;

Fl_Group *grpButtons=(Fl_Group *)0;

int main(int argc, char **argv) {
  { window = new Fl_Double_Window(480, 400, mygettext("Tiny Core Grub4dos Installation"));
    window->user_data((void*)("quit"));
    { wWizard = new Fl_Wizard(25, 30, 435, 325, mygettext("Tiny Core Grub4dos Installation"));
      wWizard->labeltype(FL_ENGRAVED_LABEL);
      { grpType = new Fl_Group(25, 30, 435, 325);
        { Fl_Group* o = new Fl_Group(55, 65, 375, 30, mygettext("Please Select Version to Install"));
          o->box(FL_ENGRAVED_FRAME);
          { btnMicro = new Fl_Check_Button(80, 70, 115, 25, mygettext("Micro Core"));
            btnMicro->type(102);
            btnMicro->down_box(FL_DOWN_BOX);
            btnMicro->callback((Fl_Callback*)cb_btnMicro, (void*)("microcore"));
          } // Fl_Check_Button* btnMicro
          { btnTiny = new Fl_Check_Button(265, 70, 115, 25, mygettext("Tiny Core"));
            btnTiny->type(102);
            btnTiny->down_box(FL_DOWN_BOX);
            btnTiny->callback((Fl_Callback*)cb_btnTiny, (void*)("tinycore"));
          } // Fl_Check_Button* btnTiny
          o->end();
        } // Fl_Group* o
        { fullpathOutput = new Fl_Output(55, 98, 375, 27);
        } // Fl_Output* fullpathOutput
        { Fl_Group* o = new Fl_Group(110, 140, 255, 25);
          { Fl_Check_Button* o = new Fl_Check_Button(115, 140, 70, 21, mygettext("Frugal"));
            o->type(102);
            o->down_box(FL_DOWN_BOX);
            o->callback((Fl_Callback*)cb_Frugal, (void*)("frugal"));
            installMode = "frugal";
          } // Fl_Check_Button* o
          { Fl_Check_Button* o = new Fl_Check_Button(230, 140, 90, 21, mygettext("Embedded"));
            o->type(102);
            o->down_box(FL_DOWN_BOX);
            o->value(1);
            o->callback((Fl_Callback*)cb_Embedded, (void*)("embedded"));
            installMode = "embedded";
          } // Fl_Check_Button* o
          o->end();
        } // Fl_Group* o
        { brwTarget = new Fl_Browser(55, 190, 370, 130, mygettext("Select Target Disk"));
          brwTarget->type(2);
          brwTarget->callback((Fl_Callback*)cb_brwTarget);
          brwTarget->align(FL_ALIGN_TOP);
          brwTarget->deactivate();
        } // Fl_Browser* brwTarget
        grpType->end();
      } // Fl_Group* grpType
      { grpFormat = new Fl_Group(25, 30, 435, 325);
        grpFormat->hide();
        { FormatType = new Fl_Group(100, 95, 270, 230, mygettext("Formatting Options"));
          { Fl_Round_Button* o = new Fl_Round_Button(140, 105, 195, 20, mygettext("No formatting, use existing."));
            o->type(102);
            o->down_box(FL_ROUND_DOWN_BOX);
            o->value(1);
            o->callback((Fl_Callback*)cb_No, (void*)("none"));
            format = "none";
          } // Fl_Round_Button* o
          { Fl_Round_Button* o = new Fl_Round_Button(140, 125, 195, 20, mygettext("ext2"));
            o->type(102);
            o->down_box(FL_ROUND_DOWN_BOX);
            o->callback((Fl_Callback*)cb_ext2, (void*)("ext2"));
          } // Fl_Round_Button* o
          { Fl_Round_Button* o = new Fl_Round_Button(140, 145, 195, 20, mygettext("ext3"));
            o->type(102);
            o->down_box(FL_ROUND_DOWN_BOX);
            o->callback((Fl_Callback*)cb_ext3, (void*)("ext3"));
          } // Fl_Round_Button* o
          { Fl_Round_Button* o = new Fl_Round_Button(140, 165, 195, 20, mygettext("ext4"));
            o->type(102);
            o->down_box(FL_ROUND_DOWN_BOX);
            o->callback((Fl_Callback*)cb_ext4, (void*)("ext4"));
          } // Fl_Round_Button* o
          { Fl_Round_Button* o = new Fl_Round_Button(140, 185, 195, 20, mygettext("vfat"));
            o->type(102);
            o->down_box(FL_ROUND_DOWN_BOX);
            o->callback((Fl_Callback*)cb_vfat, (void*)("vfat"));
          } // Fl_Round_Button* o
          FormatType->end();
        } // Fl_Group* FormatType
        grpFormat->end();
      } // Fl_Group* grpFormat
      { grpBoot = new Fl_Group(25, 30, 435, 325, mygettext("Boot Options"));
        grpBoot->hide();
        { brwBootRef = new Fl_Browser(35, 55, 415, 250, mygettext("Boot Options Reference List"));
          brwBootRef->textfont(4);
          brwBootRef->align(FL_ALIGN_TOP);
        } // Fl_Browser* brwBootRef
        { options = new Fl_Input(35, 325, 415, 20, mygettext("Enter Spaces Separated Options From Examples Above"));
          options->labeltype(FL_EMBOSSED_LABEL);
          options->align(FL_ALIGN_TOP);
        } // Fl_Input* options
        grpBoot->end();
      } // Fl_Group* grpBoot
      { grpReview = new Fl_Group(25, 30, 435, 325);
        grpReview->hide();
        { brwReview = new Fl_Browser(45, 55, 390, 245, mygettext("Review"));
          brwReview->align(FL_ALIGN_TOP);
        } // Fl_Browser* brwReview
        { btnProceed = new Fl_Button(210, 315, 64, 20, mygettext("Proceed"));
          btnProceed->callback((Fl_Callback*)btnProceedCB);
        } // Fl_Button* btnProceed
        grpReview->end();
      } // Fl_Group* grpReview
      wWizard->value(wWizard->child(0));
      wWizard->end();
    } // Fl_Wizard* wWizard
    { grpButtons = new Fl_Group(25, 365, 440, 40);
      grpButtons->deactivate();
      { Fl_Button* o = new Fl_Button(180, 365, 45, 25, mygettext("@<"));
        o->callback((Fl_Callback*)btnCB, (void*)("prev"));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(230, 365, 45, 25, mygettext("@>"));
        o->callback((Fl_Callback*)btnCB, (void*)("next"));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(130, 365, 45, 25, mygettext("@<<"));
        o->callback((Fl_Callback*)btnCB, (void*)("begin"));
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(280, 365, 45, 25, mygettext("@>>"));
        o->callback((Fl_Callback*)btnCB, (void*)("last"));
      } // Fl_Button* o
      grpButtons->end();
    } // Fl_Group* grpButtons
    window->end();
    window->resizable(window);
  } // Fl_Double_Window* window
  brwTarget->deactivate();
prepTarget();
  window->show(argc, argv);
  return Fl::run();
}
