// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include "appsaudit.h"
// (c) Robert Shingledecker 2009
#include <iostream>
#include <fstream>
#include <string>
#include <FL/fl_message.H>
#include <FL/Fl_File_Chooser.H>
using namespace std;
static string tcedir, target_dir; 
static string command; 
static string select_extn, select_results; 
static string option_type, report_type, update_type; 
static ifstream ifaberr; 
static string aberr; 
static string msg; 
static string copy2fsList, copy2fsFlag, onbootList; 

void depends_callback(Fl_Widget *, void* userdata) {
  report_type = (const char*) userdata;
option_type = "";

if (userdata == "builddb")
{
   window->cursor(FL_CURSOR_WAIT);
   Fl::flush();
   command = "/usr/bin/tce-audit builddb " + target_dir +"/";
   system(command.c_str());
   string listfile = target_dir + "/tce.lst";
   brw_extn->load(listfile.c_str());
   brw_results->load("/tmp/audit_results.txt");
   menu_nodepends->activate();
   menu_auditall->activate();
   menu_marked->activate();
   box_extn->label(target_dir.c_str());
   box_results->label("Results");
   window->cursor(FL_CURSOR_DEFAULT);
   Fl::flush();
} else if (userdata == "dependson" or userdata == "requiredby" or userdata == "audit") 
{
   report_type = (const char*) userdata;
   string loadit = "tce-audit " + report_type + " " + target_dir + "/" + select_extn;
   int results = system(loadit.c_str());
   if (results == 0 )
   {
      brw_results->load("/tmp/audit_results.txt");
   } else {
      fl_message("error detected!");
   }
} else if (userdata == "auditall" or userdata == "nodepends")
{
   box_results->label("Results");
   menu_delete->deactivate();
   menu_dependson->deactivate();
   menu_requiredby->deactivate();
   menu_missing->deactivate();
   command = "tce-audit " + report_type + " " + target_dir + "/";
   int results = system(command.c_str());
   if (results == 0 )
   {
      brw_results->load("/tmp/audit_results.txt");
   } else {
      ifstream ifaberr("/tmp/aberr");
      msg = "Error: ";
      getline(ifaberr,aberr);
      while (ifaberr) 
      {
         msg = msg + aberr + "\n";
         getline(ifaberr,aberr);
      }
      ifaberr.close();
      fl_message(msg.c_str());
   }
} else if (userdata == "delete")
{
   report_type = (const char*) userdata;
   command = "tce-audit " + report_type + " " + target_dir + "/" + select_extn;
   int results = system(command.c_str());
   if (results == 0 )
   {
      brw_results->load("/tmp/audit_results.txt");
   } else {
      fl_message("error detected!");
   }
} else if (userdata == "display_marked")
{
     box_results->label("Results");
     brw_results->load("/tmp/audit_marked.lst");
} else if (userdata == "quit")
{
    exit(0);
}
}

void options_callback(Fl_Widget *, void* userdata) {
  option_type = (const char*) userdata;
report_type = "";

if (userdata == "default")
{
   command = "ls "+ copy2fsFlag + " >/dev/null 2>&1";
   int results = system(command.c_str());
   if (results == 0)
   {
     command = "rm -f "+ copy2fsFlag;
     system(command.c_str());
     box_results->label("copy2fs.flg removed.");
   } else
   {  
     command = "touch " + target_dir + "/copy2fs.flg";
     system(command.c_str());
     box_results->label("copy2fs.flg set");
   }
} else if (userdata == "select") 
{
   box_extn->label(target_dir.c_str());
   command = "ls " + target_dir + "|grep -E .tcz$ > tce.lst";
   system(command.c_str());
   brw_extn->load("tce.lst");
   brw_results->load(copy2fsList.c_str());
   box_results->label("Current copy2fs.lst");
} else if (userdata == "exit_copy")
{
    option_type = "";
    box_results->label("Results");
    brw_extn->clear();
    brw_results->clear();
}
}

void updates_callback(Fl_Widget *, void* userdata) {
  update_type = (const char*) userdata;
report_type = "";

if (userdata == "update") 
{
   brw_extn->clear();
   window->cursor(FL_CURSOR_WAIT);
   Fl::flush();
   command = "tce-update list " + target_dir + " > /tmp/apps_upd.lst";
   system(command.c_str());
   box_extn->label(target_dir.c_str());
   brw_extn->load("/tmp/apps_upd.lst");
   box_results->label("Results");
   window->cursor(FL_CURSOR_DEFAULT);
   Fl::flush();
} else if (userdata == "exit_updates")
{
    update_type = "";
    box_results->label("Results");
    brw_extn->clear();
    brw_results->clear();
//    Fl::flush();
}
}

void onboot_callback(Fl_Widget *, void* userdata) {
  if (userdata == "onboot" )
{
  target_dir = tcedir + "/optional";
  report_type = "onboot";
  brw_extn->clear();
  window->cursor(FL_CURSOR_WAIT);
  Fl::flush();
  command = "ls " + target_dir + "| egrep .tcz$ > /tmp/apps_sel.lst";
  system(command.c_str());
  box_extn->label(target_dir.c_str());
  brw_extn->load("/tmp/apps_sel.lst");
  box_results->label("On Boot Items");
  brw_results->load(onbootList.c_str());
  window->cursor(FL_CURSOR_DEFAULT);
  Fl::flush();
}
 
if (userdata == "exit_onboot")
{
  report_type.empty();
  box_results->label("Results");
  brw_extn->clear();
  brw_results->clear();
} 
 
if (userdata == "quit") 
  exit(0);
}

void brw_extn_callback(Fl_Widget *, void *) {
  if (brw_extn->value())
{
   select_extn = brw_extn->text(brw_extn->value());
   if ( report_type.length() > 0 )
   {
     box_results->label(select_extn.c_str());
     menu_dependson->activate();
     menu_requiredby->activate();
     menu_missing->activate();
     menu_delete->activate();
     brw_results->load("");
   } 
   if ( option_type == "select" )
   {
     command = "echo " + select_extn + " >> " + copy2fsList;
     system(command.c_str());
     brw_results->load(copy2fsList.c_str());
   }
   if ( update_type == "update" )
   {
     command = "tce-update update " + select_extn + ".md5.txt >/tmp/apps_upd.lst";
     cout << command << endl;
     brw_results->load("");
     system(command.c_str());
     brw_results->load("/tmp/apps_upd.lst");
   }
   
   if ( report_type == "onboot" )
   {
     command = "echo " + select_extn + " >> " + onbootList;
     system(command.c_str());
     box_results->label("On Boot Items");
     brw_results->load(onbootList.c_str());
   }   
}
}

void brw_results_callback(Fl_Widget *, void *) {
  if (brw_results->value())
{
   select_results = brw_results->text(brw_results->value());
   if ( option_type.length() > 0 )
   {
     command = "sed -i '/" + select_results + "/d' " + copy2fsList;
     system(command.c_str());
     brw_results->load(copy2fsList.c_str());
   }
   cout << report_type << endl;
   if (report_type == "delete" or report_type == "display_marked")
   {
     string target = select_results.substr(select_results.find_last_of("/")+1);
     command = "sed -i '/" + target + "/d' /tmp/audit_marked.lst";
     cout << command << endl;
     system(command.c_str());
     brw_results->load("/tmp/audit_marked.lst");
   }
   if (report_type == "onboot")
   {
     command = "sed -i '/" + select_results + "/d' " + onbootList;
     system(command.c_str());
     box_results->label("On Boot Items");
     brw_results->load(onbootList.c_str());
   }  
}
}

Fl_Double_Window *window=(Fl_Double_Window *)0;

Fl_Menu_Item menu_[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Quit", 0,  (Fl_Callback*)depends_callback, (void*)("quit"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Dependencies", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Update Dependencies", 0,  (Fl_Callback*)depends_callback, (void*)("builddb"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"List Dependencies", 0,  (Fl_Callback*)depends_callback, (void*)("dependson"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"LIst Required By", 0,  (Fl_Callback*)depends_callback, (void*)("requiredby"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"List Missing Dependencies", 0,  (Fl_Callback*)depends_callback, (void*)("audit"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Display All with No Dependencies", 0,  (Fl_Callback*)depends_callback, (void*)("nodepends"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Display All with Missing Dependencies", 0,  (Fl_Callback*)depends_callback, (void*)("auditall"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Mark for Deletion", 0,  (Fl_Callback*)depends_callback, (void*)("delete"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {"Display Marked for Deletion", 0,  (Fl_Callback*)depends_callback, (void*)("display_marked"), 1, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Install Options", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Toggle Default Copy Install", 0,  (Fl_Callback*)options_callback, (void*)("default"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Selective Copy Install", 0,  (Fl_Callback*)options_callback, (void*)("select"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit Install Options", 0,  (Fl_Callback*)options_callback, (void*)("exit_copy"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Updates", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Check for Updates", 0,  (Fl_Callback*)updates_callback, (void*)("update"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit Update Mode", 0,  (Fl_Callback*)updates_callback, (void*)("exit_updates"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"OnBoot", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Maintenance", 0,  (Fl_Callback*)onboot_callback, (void*)("onboot"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit OnBoot", 0,  (Fl_Callback*)onboot_callback, (void*)("exit_onboot"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Box *box_extn=(Fl_Box *)0;

Fl_Box *box_results=(Fl_Box *)0;

Fl_Browser *brw_results=(Fl_Browser *)0;

Fl_Browser *brw_extn=(Fl_Browser *)0;

int main(int argc, char **argv) {
  { window = new Fl_Double_Window(675, 375, "AppsAudit");
    window->callback((Fl_Callback*)onboot_callback, (void*)("quit"));
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 685, 20);
      o->menu(menu_);
    } // Fl_Menu_Bar* o
    { box_extn = new Fl_Box(0, 24, 200, 16);
      box_extn->labelfont(1);
      box_extn->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
    } // Fl_Box* box_extn
    { box_results = new Fl_Box(225, 24, 430, 16, "Results");
      box_results->labelfont(1);
    } // Fl_Box* box_results
    { brw_results = new Fl_Browser(225, 45, 430, 325);
      brw_results->type(1);
      brw_results->textfont(4);
      brw_results->callback((Fl_Callback*)brw_results_callback);
    } // Fl_Browser* brw_results
    { brw_extn = new Fl_Browser(0, 45, 200, 325);
      brw_extn->type(1);
      brw_extn->textfont(4);
      brw_extn->callback((Fl_Callback*)brw_extn_callback);
    } // Fl_Browser* brw_extn
    window->end();
    window->resizable(window);
  } // Fl_Double_Window* window
  ifstream tcedir_file("/opt/.tce_dir");
getline(tcedir_file,tcedir);
tcedir_file.close();
target_dir = tcedir + "/optional";
box_extn->label(target_dir.c_str());

copy2fsList = target_dir + "/copy2fs.lst";
copy2fsFlag = target_dir + "/copy2fs.flg";
onbootList = tcedir + "/onboot.lst";

option_type.empty();
report_type.empty();

command = "ls " + target_dir + "/tce.db >/dev/null 2>&1";

int results = system(command.c_str());
if (results == 0)
{
  report_type = "builddb";
  string listfile = target_dir + "/tce.lst";
  box_extn->label(target_dir.c_str());
  brw_extn->load(listfile.c_str());
  menu_nodepends->activate();
  menu_auditall->activate();
  menu_marked->activate();
}
  window->show(argc, argv);
  return Fl::run();
}
