// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include <libintl.h>
#include "network.h"
// (c) Robert Shingledecker
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>
#include <locale.h>
using namespace std;
static string hostname; 

void btnCallback(Fl_Widget*, void* userdata) {
  if (userdata == "dhcpYes" )
{
   ipAddressInput->deactivate();
   netMaskInput->deactivate();
   broadcastInput->deactivate();
   gatewayInput->deactivate();
   nameserv1Input->deactivate();
   nameserv2Input->deactivate();
}
if (userdata == "dhcpNo" )
{
   ipAddressInput->activate();
   netMaskInput->activate();
   broadcastInput->activate();
   gatewayInput->activate();
   nameserv1Input->activate();
   nameserv2Input->activate();
}
if (userdata == "ip" )
{
   string commandHead = "ipcalc -b ";
   string commandTail = "| cut -f2 -d=";
   string command = commandHead + ipAddressInput->value() + " " + netMaskInput->value() + commandTail;
   cout << command << endl;
   FILE *CMD_fp = NULL;
   if ((CMD_fp = popen(command.c_str(),"r"))==NULL)
   {
      cerr << "popen failed" << endl;
   }
   char result[1024];
   if ( fgets(result,1023,CMD_fp)==NULL)
   {
      cerr << "popen results returned NULL" << endl;
   }
   string broadcast = result;
   broadcast = broadcast.substr(0,broadcast.length()-1);
   broadcastInput->value(broadcast.c_str());
   
   string ip = ipAddressInput->value();
   int loc = ip.rfind(".");            
   string gw = ip.substr(0,loc) + ".254";
   gatewayInput->value(gw.c_str());
}   

if (userdata == "apply")
{
   string interface = interfaceInput->value();
   string ipaddress = ipAddressInput->value();
   string netmask   = netMaskInput->value();
   string broadcast = broadcastInput->value();
   string gateway   = gatewayInput->value();
   string nameserver1 = nameserv1Input->value();
   string nameserver2 = nameserv2Input->value();
   string command;
   if (dhcpYesBtn->value() == 1)
   {
      command = command + "sudo udhcpc -H " + hostname + " -b -i " + interfaceInput->value() + " &";
      system(command.c_str());
   }
   if (dhcpNoBtn->value() == 1)
   {
      command = "sudo /usr/bin/pkill udhcpc >/dev/null";
      system(command.c_str());
      command = "sudo /sbin/ifconfig ";
      command = command + interface + " " + ipaddress + " netmask " + netmask + " broadcast " + broadcast + " up";
      system(command.c_str());
      command = "sudo /sbin/route add default gw ";
      command = command + gateway;
      system(command.c_str());
      command = "echo nameserver ";
      command = command + nameserver1 + "|sudo tee /etc/resolv.conf";
      system(command.c_str());
      if ( ! nameserver2.empty() )
      {
         command = "echo nameserver ";
         command = command + nameserver2 + "|sudo tee -a /etc/resolv.conf";
         system(command.c_str());
      
      }
   }
   if (SaveYesBtn->value() == 1 )
   {
      ofstream fout(("/opt/"+interface + ".sh").c_str());
      if (! fout.is_open())
      {
         cerr << "Can't open output file." << endl;
         exit(EXIT_FAILURE);
      }
      fout << "#!/bin/sh" << endl;
      fout << "pkill udhcpc" << endl;
      if ( dhcpYesBtn->value() == 1)
         fout << "udhcpc -H " << hostname << " -b -i " << interface << endl;
      else
      {
         fout << "ifconfig " << interface << " " << ipaddress << " netmask " << netmask << " broadcast " << broadcast << " up" << endl;
         fout << "route add default gw " << gateway << endl;
         fout << "echo nameserver " << nameserver1 << " > /etc/resolv.conf" << endl;
         if ( ! nameserver2.empty() )
            fout << "echo nameserver " << nameserver2 << " >> /etc/resolv.conf" << endl; 
      }
      command = "sudo chmod +x /opt/" + interface +".sh";
      system(command.c_str());
      command = "sed -i '/" + interface +".sh/d' /opt/bootlocal.sh";
      system(command.c_str());
      command = "echo '/opt/" + interface + ".sh &' >> /opt/bootlocal.sh";
      system(command.c_str());
      command = "sed -i '/" + interface + ".sh/d' /opt/.filetool.lst";
      system(command.c_str());
      command = "echo opt/" + interface + ".sh >> /opt/.filetool.lst";
      system(command.c_str());
   }        
}      
if (userdata == "exit")
   exit(0);
}

Fl_Input *interfaceInput=(Fl_Input *)0;

Fl_Round_Button *dhcpYesBtn=(Fl_Round_Button *)0;

Fl_Round_Button *dhcpNoBtn=(Fl_Round_Button *)0;

Fl_Input *ipAddressInput=(Fl_Input *)0;

Fl_Input *netMaskInput=(Fl_Input *)0;

Fl_Input *broadcastInput=(Fl_Input *)0;

Fl_Input *gatewayInput=(Fl_Input *)0;

Fl_Input *nameserv1Input=(Fl_Input *)0;

Fl_Input *nameserv2Input=(Fl_Input *)0;

Fl_Round_Button *SaveYesBtn=(Fl_Round_Button *)0;

Fl_Round_Button *SaveNoBtn=(Fl_Round_Button *)0;

int main(int argc, char **argv) {
  Fl_Double_Window* w;
  setlocale(LC_ALL, "");
bindtextdomain("tinycore","/usr/local/share/locale");
textdomain("tinycore");
  { Fl_Double_Window* o = new Fl_Double_Window(160, 415, gettext("Network"));
    w = o;
    { Fl_Box* o = new Fl_Box(30, 2, 90, 28, gettext("Network"));
      o->labeltype(FL_ENGRAVED_LABEL);
      o->labelsize(18);
    } // Fl_Box* o
    { interfaceInput = new Fl_Input(20, 41, 115, 24, gettext("Interface"));
      interfaceInput->labelfont(1);
      interfaceInput->labelsize(12);
      interfaceInput->align(FL_ALIGN_TOP_LEFT);
      interfaceInput->align(1);interfaceInput->value("eth0");
    } // Fl_Input* interfaceInput
    { Fl_Group* o = new Fl_Group(5, 85, 155, 20, gettext("Use DHCP Broadcast?"));
      o->labelfont(1);
      o->labelsize(12);
      { dhcpYesBtn = new Fl_Round_Button(30, 90, 45, 15, gettext("yes"));
        dhcpYesBtn->down_box(FL_ROUND_DOWN_BOX);
        dhcpYesBtn->selection_color((Fl_Color)2);
        dhcpYesBtn->callback((Fl_Callback*)btnCallback, (void*)("dhcpYes"));
        dhcpYesBtn->type(FL_RADIO_BUTTON);
      } // Fl_Round_Button* dhcpYesBtn
      { dhcpNoBtn = new Fl_Round_Button(75, 90, 45, 15, gettext("no"));
        dhcpNoBtn->down_box(FL_ROUND_DOWN_BOX);
        dhcpNoBtn->value(1);
        dhcpNoBtn->selection_color((Fl_Color)2);
        dhcpNoBtn->callback((Fl_Callback*)btnCallback, (void*)("dhcpNo"));
        dhcpNoBtn->type(FL_RADIO_BUTTON);
      } // Fl_Round_Button* dhcpNoBtn
      o->end();
    } // Fl_Group* o
    { ipAddressInput = new Fl_Input(20, 121, 115, 24, gettext("IP Address"));
      ipAddressInput->labelfont(1);
      ipAddressInput->labelsize(12);
      ipAddressInput->callback((Fl_Callback*)btnCallback, (void*)("ip"));
      ipAddressInput->align(FL_ALIGN_TOP_LEFT);
      ipAddressInput->align(1);
    } // Fl_Input* ipAddressInput
    { netMaskInput = new Fl_Input(20, 161, 115, 24, gettext("Network Mask"));
      netMaskInput->labelfont(1);
      netMaskInput->labelsize(12);
      netMaskInput->align(FL_ALIGN_TOP_LEFT);
      netMaskInput->align(1); netMaskInput->value("255.255.255.0");
    } // Fl_Input* netMaskInput
    { broadcastInput = new Fl_Input(20, 201, 115, 24, gettext("Broadcast"));
      broadcastInput->labelfont(1);
      broadcastInput->labelsize(12);
      broadcastInput->align(FL_ALIGN_TOP_LEFT);
      broadcastInput->align(1);
    } // Fl_Input* broadcastInput
    { gatewayInput = new Fl_Input(20, 241, 115, 24, gettext("Gateway"));
      gatewayInput->labelfont(1);
      gatewayInput->labelsize(12);
      gatewayInput->align(FL_ALIGN_TOP_LEFT);
      gatewayInput->align(1);
    } // Fl_Input* gatewayInput
    { nameserv1Input = new Fl_Input(20, 281, 115, 24, gettext("NameServers"));
      nameserv1Input->labelfont(1);
      nameserv1Input->labelsize(12);
      nameserv1Input->align(FL_ALIGN_TOP_LEFT);
      nameserv1Input->align(1);
    } // Fl_Input* nameserv1Input
    { nameserv2Input = new Fl_Input(20, 306, 115, 24);
      nameserv2Input->labeltype(FL_NO_LABEL);
      nameserv2Input->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Input* nameserv2Input
    { Fl_Group* o = new Fl_Group(20, 350, 130, 10, gettext("Save Configuration?"));
      o->labelfont(1);
      o->labelsize(12);
      { SaveYesBtn = new Fl_Round_Button(30, 350, 45, 10, gettext("yes"));
        SaveYesBtn->down_box(FL_ROUND_DOWN_BOX);
        SaveYesBtn->value(1);
        SaveYesBtn->selection_color((Fl_Color)2);
        SaveYesBtn->type(FL_RADIO_BUTTON);
      } // Fl_Round_Button* SaveYesBtn
      { SaveNoBtn = new Fl_Round_Button(75, 350, 50, 10, gettext("no"));
        SaveNoBtn->down_box(FL_ROUND_DOWN_BOX);
        SaveNoBtn->selection_color((Fl_Color)2);
        SaveNoBtn->type(FL_RADIO_BUTTON);
      } // Fl_Round_Button* SaveNoBtn
      o->end();
    } // Fl_Group* o
    { Fl_Button* o = new Fl_Button(15, 375, 65, 25, gettext("&Apply"));
      o->callback((Fl_Callback*)btnCallback, (void*)("apply"));
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(85, 375, 65, 25, gettext("E&xit"));
      o->callback((Fl_Callback*)btnCallback, (void*)("exit"));
    } // Fl_Button* o
    o->end();
  } // Fl_Double_Window* o
  FILE *CMD_fp = NULL;
if ((CMD_fp = popen("grep '^nameserver' /etc/resolv.conf|cut -f2 -d' '","r"))==NULL)
{
   cerr << "popen failed" << endl;
   return 1;
}
char result[1024];
string ns;
if ( fgets(result,1023,CMD_fp)!=NULL)
{
   ns = result;
   ns = ns.substr(0,ns.length()-1);
   nameserv1Input->value(ns.c_str());
}
if ( fgets(result,1023,CMD_fp)!=NULL)
{
   ns = result;
   ns = ns.substr(0,ns.length()-1);
   nameserv2Input->value(ns.c_str());
}
fclose(CMD_fp);

ifstream fin("/etc/hostname");
getline(fin,hostname);
fin.close();
  w->show(argc, argv);
  return Fl::run();
}
